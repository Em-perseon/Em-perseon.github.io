
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>CHATDB-AUGMENTING-LLMsS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY | XuSibo&#39;s Blog</title>
    <meta name="author" content="Rick" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>XUSIBO&#39;S BLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;XUSIBO&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>CHATDB-AUGMENTING-LLMsS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/14
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/CoM-LLMs-SQL/" style="color: #ffa2c4">
                    CoM LLMs SQL
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>具有内存的大型语言模型(LLMs)在计算上是通用的，然而，主流LLMs并没有<strong>充分利用内存</strong>，而且设计受到生物大脑的严重影响。传统的神经记忆机制由于其<strong>近似性质</strong>和<strong>容易累积错误</strong>，无法支持LLMs<strong>模拟复杂推理</strong>。在本文中，我们从现代计算机体系结构中寻求灵感，以<strong>增强具有符号记忆的LLMs</strong>，用于复杂的<strong>多跳推理</strong>。这样一个符号内存框架被实例化为一个LLMs和一组SQL数据库，其中LLMs生成SQL指令来操作SQL数据库。</p>
<ul>
<li>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2306.03901">https://arxiv.org/abs/2306.03901</a></li>
<li>代码链接：<a target="_blank" rel="noopener" href="https://github.com/huchenxucs/ChatDB">https://github.com/huchenxucs/ChatDB</a></li>
</ul>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p>LLMs存在以下局限性：</p>
<ul>
<li><p>与语言模型的多回合交互会产生大量的令牌，这很容易<strong>超过llm的输入令牌限制</strong>。</p>
<ul>
<li>令牌：代表模型可以理解和生成的最小意义单位，是LLM 进行处理的最小单元。在文本的背景下，一个Token可以是一个单词、单词的一部分（子词）或甚至是一个字符，这取决于Token化过程。</li>
<li>随着交互的进行，llm必须维护上下文信息(例如，用户输入和先前的响应)，并根据累积的数据生成响应。然而，简单地将所有上下文信息连接起来并将其塞进llm很容易超出llm的处理能力并积累错误，从而导致模型失去对对话的跟踪并产生不太准确的响应。</li>
</ul>
</li>
<li><p>一些神经记忆机制已被探索已克服llm的token输入有限问题。<strong>记忆组件</strong>作为存储和检索系统，从以前的交互中获取相关信息。然而，用传统的神经记忆增强llm通常会导致<strong>存储、检索和操作内存中的历史信息的困难</strong>，特别是对于需要复杂的多跳推理的任务。两个主要原因是:</p>
<ul>
<li>它们<strong>没有以结构化的形式存储历史信息</strong>;</li>
<li>它们对存储在存储器中的信息的操作<strong>不是象征性的</strong>，因为它们都依赖于一些向量相似性计算，这些计算可能是不准确的，从而导致错误的积累。</li>
</ul>
</li>
<li><p>解决方法：</p>
<ul>
<li>使用SQL语言作为llm的<strong>新型符号内存</strong>。整个框架命名为ChatDB。结构如下图所示：</li>
</ul>
<img src="/2024/07/14/CHATDB-AUGMENTING-LLMS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-14%20102945.jpg" class="" title="屏幕截图 2024-07-14 102945">
<p>图1:ChatDB的总体工作流程。LLM控制器控制对存储器的读写操作。存储器存储历史信息并提供相关的历史信息，以帮助响应用户输入。在ChatDB中，我们专注于用数据库作为符号内存来增强llm</p>
<ul>
<li><p>具体组成</p>
<ul>
<li><p>LLM控制器：LLM控制器可以是任何常用的LLM </p>
</li>
<li><p>LLM的内存可以是符号或非符号，也可以是两者的组合，它负责存储历史信息，并在需要时提供信息，以帮助LLM响应用户输入</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在ChatDB中，我们着重于<strong>使用数据库作为符号内存</strong>，它允许通过<strong>执行符号语言(即SQL语句)来结构化地存储历史信息</strong>。这些SQL语句是<strong>由LLM生成的</strong>。在需要精确记录、修改、查询、删除和分析历史数据的场景中，将数据库合并为符号内存特别有用。例如，商店经理需要维护日常销售记录，而使用纯文本或矩阵作为内存是不合适的</p>
</li>
<li><p>然而，使用数<strong>据库作为外部符号内存</strong>是非常合适的。数据库可以使用SQL语句进行精确的操作，包括数据的插入、删除、更新和选择。因此，使用数据库作为外部符号存储器确保了管理和操作历史数据的准确性和效率，显著提高了llm在需要高精度和长期数据记录和处理的场景中的性能。</p>
<ul>
<li><strong>符号内存</strong>是指大脑或人工智能系统中存储和处理符号信息的能力。<strong>就是利用SQL去处理数据</strong></li>
<li><strong>外部符号内存</strong>是指将符号信息存储在外部设备或介质上，而不是仅限于系统内部存储。<strong>是数据库本身，用来存储数据的地方</strong></li>
</ul>
</li>
<li><p>在ChatDB框架中，我们提出了<strong>内存链(CoM)</strong>方法来更有效地操作外部符号内存，从而进一步增强llm的推理能力。<strong>内存链方法</strong>将<strong>用户输入转换为一系列导致最终结果的中间内存操作步骤</strong>。通过内存链方法，<strong>将一个复杂的问题分解为多个记忆操作步骤</strong>，大大降低了问题解决的复杂性。在ChatDB中，每个中间步骤都涉及一个或多个SQL语句。</p>
</li>
<li><p><strong>总结</strong>：首先，建议<strong>用数据库作为llm的外部符号内存</strong>，允许历史数据的结构化存储，并允许使用SQL语句进行符号和复杂的数据操作。其次，我们的<strong>内存链方法</strong>通过将用户输入转换为多步中间内存操作来实现有效的内存操作，这增强了ChatDB的性能，使其能够以更高的准确性和稳定性处理复杂的多表数据库交互。</p>
</li>
</ul>
<h1 id="3-ChatDB"><a href="#3-ChatDB" class="headerlink" title="3. ChatDB"></a>3. ChatDB</h1><h2 id="3-1-任务定义"><a href="#3-1-任务定义" class="headerlink" title="3.1 任务定义"></a>3.1 任务定义</h2><ul>
<li>给定用户以自然语言输入和数据库中现有表的详细信息(如果没有现有表，则不需要)，目标是操作符号内存，即外部数据库，以满足用户的请求。<ul>
<li>例如，如果用户(例如，商店经理)命令是记录、修改、查询和删除特定的数据，那么相应的SQL操作应该是分别在适当的表中插入、更新、选择和删除相关数据。这些操作通常涉及数据库中的多个表</li>
</ul>
</li>
</ul>
<h2 id="3-2框架概述"><a href="#3-2框架概述" class="headerlink" title="3.2框架概述"></a>3.2框架概述</h2><p>ChatDB框架由三个主要阶段组成：<strong>输入处理</strong>、<strong>记忆链</strong>和<strong>响应总结</strong></p>
<img src="/2024/07/14/CHATDB-AUGMENTING-LLMS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY/image-20240715224432295.png" class="" title="image-20240715224432295">
<ul>
<li><strong>输入处理：</strong>如果响应用户输入需要使用内存，ChatDB通过<strong>llm生成一系列中间步骤来操作符号内存</strong>。否则，我们直接使用llm来生成回复。</li>
<li><strong>Chain-of-Memory：</strong>ChatDB执行一系列中间内存操作步骤来与符号内存交互。ChatDB根据<strong>先前生成的一系列SQL语句依次操作符号内存</strong>，包括插入、更新、选择、删除等操作。外部数据库执行相应的SQL语句，更新数据库，并返回结果。值得注意的是，ChatDB在执行内存操作步骤之前，<strong>会根据前面SQL语句的结果来决定是否更新内存操作步骤</strong>。ChatDB按照相同的过程执行下一步，直到完成对内存的所有操作。</li>
<li><strong>响应总结：</strong>ChatDB根据一系列<strong>内存链步骤的结果总结对用户的最终响应</strong></li>
</ul>
<h2 id="3-3内存链"><a href="#3-3内存链" class="headerlink" title="3.3内存链"></a>3.3内存链</h2><p>思维链强调将复杂推理分解为一系列中间步骤。</p>
<p>通过提供符号内存机制来支持与这些中间步骤相关联的存储，可以将内存链(CoM)视为一种增强思维链的方法。</p>
<p>内存链的目的是提高llm在操作符号内存时的推理能力和鲁棒性。该方法包括<strong>将用户输入转换为中间内存操作序列</strong>，使llm能够<strong>以符号方式更准确有效地操作内存</strong>。对于涉及与历史数据进行复杂而准确交互的实际应用程序(例如管理设置中的记录保存和数据分析)，操作符号内存的能力特别有价值。</p>
<p>为了提高我们方法的性能和稳定性，我们采用了<strong>上下文学习</strong>，提供了几个<strong>内存链步骤序列</strong>和<strong>思维链提示</strong>的提示示例。一个强大而准确的<strong>内存链</strong>过程使llm能够更好地对符号记忆进行推理，并处理更复杂的场景。</p>
<ul>
<li><p><strong>上下文学习</strong>是指模型在给定的上下文环境中学习和推理的能力。通过提供额外的上下文信息，模型能够更准确地理解输入内容并作出相应的反应。</p>
</li>
<li><p><strong>思维链提示</strong>是指在模型推理过程中，通过提供明确的思维过程提示，引导模型逐步进行复杂推理。这种方法能够帮助模型在多步骤推理中保持逻辑一致性和准确性。</p>
<ul>
<li><p><strong>示例：</strong> 假设我们有一个数学问题求解系统，帮助学生解决复杂的数学问题。</p>
<p><strong>问题：</strong> “如果一个数的三倍加上五等于二十，求这个数。”</p>
<p><strong>思维链提示：</strong></p>
<ol>
<li>设这个数为 xxx。</li>
<li>写出等式 3x+5=203x + 5 = 203x+5=20。</li>
<li>解方程 3x=20−53x = 20 - 53x=20−5。</li>
<li>解得 3x=153x = 153x=15。</li>
<li>求得 x=5x = 5x=5。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>内存链的优点是双重的。</p>
<ul>
<li>首先，它使llm能够以更高的精度执行复杂的数据库操作，增强了它们在符号内存上的多跳推理能力。</li>
<li>其次，通过将复杂操作分解为一系列中间内存操作，内存链方法增强了llm处理复杂多表交互的能力。</li>
</ul>
<p>这种方法使LLMs能够更好地处理边缘情况和意外情况，使其成为现实应用程序中很有前途的方法。</p>
<img src="/2024/07/14/CHATDB-AUGMENTING-LLMS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-14%20115317.jpg" class="" title="屏幕截图 2024-07-14 115317">
<h2 id="3-4与以往记忆增强llm的比较"><a href="#3-4与以往记忆增强llm的比较" class="headerlink" title="3.4与以往记忆增强llm的比较"></a>3.4与以往记忆增强llm的比较</h2><img src="/2024/07/14/CHATDB-AUGMENTING-LLMS-WITH-DATABASES-AS-THEIR-SYMBOLIC-MEMORY/image-20240714120401054.png" class="" title="image-20240714120401054">
<h1 id="4-Evaluation"><a href="#4-Evaluation" class="headerlink" title="4 Evaluation"></a>4 Evaluation</h1><h2 id="4-1实验设置"><a href="#4-1实验设置" class="headerlink" title="4.1实验设置"></a>4.1实验设置</h2><p>构建了一个模拟水果店管理的合成数据集。</p>
<p>为了评估模型的性能，我们收集了一组50个带有注释标准答案的问题。这些问题的难度各不相同，从需要多跳推理的困难问题到只需要从历史数据中检索信息的简单问题。有15个简单问题和35个难题。每个问题都由模型独立回答。</p>
<h3 id="4-1-1-模型配置"><a href="#4-1-1-模型配置" class="headerlink" title="4.1.1 模型配置"></a>4.1.1 模型配置</h3><p>ChatDB：使用的LLM为ChatGPT (GPT-3.5 Turbo)，超参数temperature设置为0。我们使用MySQL数据库作为外部符号内存。</p>
<p>基线：我们使用ChatGPT (GPT-3.5 Turbo)作为基准模型，最大令牌长度为4096。与ChatDB类似，我们将温度设置为0。</p>
<h3 id="4-1-2-数据集"><a href="#4-1-2-数据集" class="headerlink" title="4.1.2 数据集"></a>4.1.2 数据集</h3><ul>
<li>合成了一个水果店管理记录的数据集，称为“水果店数据集”。该数据集模拟了商店中的四种常见操作:购买、销售、更改价格和退货。我们确保所有历史记录都是有效的，不会遇到负面库存等问题。我们按时间顺序生成70条记录，总共约3.3万个令牌，这在ChatGPT的最大令牌长度限制(4096个令牌)之内。<ul>
<li>为什么要限制数据集的令牌长度?如果数据集的令牌长度超过ChatGPT的最大令牌长度，则需要内存。然而，主流的基于向量嵌入的记忆检索方法容易出错。这不可避免地会导致ChatGPT性能的下降，这是不希望的。</li>
<li>因此，我们故意将数据集的令牌长度设计在ChatGPT的最大令牌长度范围内，以避免使用内存并最大化模型的性能。请注意，ChatDB的性能通常不受数据集令牌长度的影响。因此，如果ChatDB在数据集较小时优于ChatGPT，则表明当数据集较大时，ChatDB也优于内存增强的ChatGPT。</li>
</ul>
</li>
</ul>
<h3 id="4-1-3处理记录"><a href="#4-1-3处理记录" class="headerlink" title="4.1.3处理记录"></a>4.1.3处理记录</h3><ul>
<li>对于ChatDB，第一步是初始化数据库。我们需要为特定的任务场景生成合理的数据库模式，并在数据库中创建表。数据库模式的生成可以手工完成，也可以使用llm完成。</li>
<li>接下来，对于数据集中的每条记录，ChatDB逐个处理它们。使用LLM控制器，ChatDB按照算法1操作外部数据库(即符号内存)。我们提供了ChatDB对Fruit Shop Dataset中的四种常见操作(即购买、销售、更改价格和退货)的响应示例<ul>
<li>值得强调的是，ChatDB是一条一条地处理记录，因此它对记录总数不敏感。此外，ChatDB中数据库操作的每一步都是象征性的，没有错误。因此，理论上，ChatDB可以处理无限数量的历史记录，而不会牺牲性能。然而，对于ChatGPT或现有的内存增强llm，过长的历史记录会显著降低性能。在这个实验中，对于ChatGPT基线，由于记录不长，我们简单地将它们视为提示的一部分。</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-回答问题"><a href="#4-1-4-回答问题" class="headerlink" title="4.1.4 回答问题"></a>4.1.4 回答问题</h3><p>ChatDB在回答问题时不再需要记录作为提示符的一部分。处理完记录后，信息被存储在符号存储器中。在算法1之后，ChatDB利用SQL语句执行一系列数据库查询(包括计算)来回答问题。另一方面，ChatGPT将记录作为提示的一部分，并直接提出问题。</p>
<h2 id="4-2结果"><a href="#4-2结果" class="headerlink" title="4.2结果"></a>4.2结果</h2><p>ChatDB的准确率明显高于ChatGPT。虽然ChatGPT能够回答简单的问题，但它在处理需要多跳推理和精确计算的困难问题时却有所欠缺。因此，ChatGPT对这些难题的准确率很低。相比之下，ChatDB显示出非常高的准确率，强调了将数据库用作符号内存的优势。该方法不仅防止了误差积累，而且提高了llm的多跳推理和精确计算能力。</p>
<p>ChatDB的优势体现在两个方面</p>
<ul>
<li>通过记忆链方法，将复杂的问题分解为多个步骤的存储操作，简化了问题的复杂性。每一步的结果都被准确地存储为中间结果，并用于后续步骤，这极大地帮助了复杂的推理。</li>
<li>符号存储器可以实现精确的操作和计算。ChatDB通过执行SQL语句，将许多计算任务委托给外部数据库，保证了每一步的准确性，防止了错误的积累。</li>
</ul>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 XuSibo&#39;s Blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Rick
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
